{"ast":null,"code":"import { defaultJsonSerializer } from './defaultJsonSerializer.js';\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js';\nimport { parseBatchRequestArgs, parseRawRequestArgs, parseRawRequestExtendedArgs, parseRequestArgs, parseRequestExtendedArgs } from './parseArgs.js';\nimport { resolveRequestDocument } from './resolveRequestDocument.js';\nimport { ClientError } from './types.js';\nimport crossFetch, * as CrossFetch from 'cross-fetch';\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = headers => {\n  let oHeaders = {};\n  if (headers) {\n    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {\n      oHeaders = HeadersInstanceToPlainObject(headers);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value;\n        }\n      });\n    } else {\n      oHeaders = headers;\n    }\n  }\n  return oHeaders;\n};\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = str => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim();\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = params => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params;\n    const search = [`query=${encodeURIComponent(cleanQuery(params_.query))}`];\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`);\n    }\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`);\n    }\n    return search.join(`&`);\n  }\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`);\n  }\n  // Batch support\n  const params_ = params;\n  const payload = params.query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: cleanQuery(currentQuery),\n      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined\n    });\n    return acc;\n  }, []);\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;\n};\nconst createHttpMethodFetcher = method => async params => {\n  const {\n    url,\n    query,\n    variables,\n    operationName,\n    fetch,\n    fetchOptions,\n    middleware\n  } = params;\n  const headers = {\n    ...params.headers\n  };\n  let queryParams = ``;\n  let body = undefined;\n  if (method === `POST`) {\n    body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer);\n    if (typeof body === `string`) {\n      // @ts-expect-error todo\n      headers[`Content-Type`] = `application/json`;\n    }\n  } else {\n    // @ts-expect-error todo needs ADT for TS to understand the different states\n    queryParams = buildRequestConfig({\n      query,\n      variables,\n      operationName,\n      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    });\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...fetchOptions\n  };\n  let urlResolved = url;\n  let initResolved = init;\n  if (middleware) {\n    const result = await Promise.resolve(middleware({\n      ...init,\n      url,\n      operationName,\n      variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    urlResolved = urlNew;\n    initResolved = initNew;\n  }\n  if (queryParams) {\n    urlResolved = `${urlResolved}?${queryParams}`;\n  }\n  return await fetch(urlResolved, initResolved);\n};\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(url, requestConfig = {}) {\n    this.url = url;\n    this.requestConfig = requestConfig;\n    /**\n     * Send a GraphQL query to the server.\n     */\n    this.rawRequest = async (...args) => {\n      const [queryOrOptions, variables, requestHeaders] = args;\n      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);\n      const {\n        headers,\n        fetch = crossFetch,\n        method = `POST`,\n        requestMiddleware,\n        responseMiddleware,\n        ...fetchOptions\n      } = this.requestConfig;\n      const {\n        url\n      } = this;\n      if (rawRequestOptions.signal !== undefined) {\n        fetchOptions.signal = rawRequestOptions.signal;\n      }\n      const {\n        operationName\n      } = resolveRequestDocument(rawRequestOptions.query);\n      return makeRequest({\n        url,\n        query: rawRequestOptions.query,\n        variables: rawRequestOptions.variables,\n        headers: {\n          ...resolveHeaders(callOrIdentity(headers)),\n          ...resolveHeaders(rawRequestOptions.requestHeaders)\n        },\n        operationName,\n        fetch,\n        method,\n        fetchOptions,\n        middleware: requestMiddleware\n      }).then(response => {\n        if (responseMiddleware) {\n          responseMiddleware(response);\n        }\n        return response;\n      }).catch(error => {\n        if (responseMiddleware) {\n          responseMiddleware(error);\n        }\n        throw error;\n      });\n    };\n  }\n  async request(documentOrOptions, ...variablesAndRequestHeaders) {\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const {\n      query,\n      operationName\n    } = resolveRequestDocument(requestOptions.document);\n    return makeRequest({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders)\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    }).then(response => {\n      if (responseMiddleware) {\n        responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (responseMiddleware) {\n        responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  // prettier-ignore\n  batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const queries = batchRequestOptions.documents.map(({\n      document\n    }) => resolveRequestDocument(document).query);\n    const variables = batchRequestOptions.documents.map(({\n      variables\n    }) => variables);\n    return makeRequest({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders)\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    }).then(response => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-expect-error todo\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}\nconst makeRequest = async params => {\n  const {\n    query,\n    variables,\n    fetchOptions\n  } = params;\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));\n  const isBatchingQuery = Array.isArray(params.query);\n  const response = await fetcher(params);\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  const successfullyReceivedData = Array.isArray(result) ? !result.some(({\n    data\n  }) => !data) : Boolean(result.data);\n  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const {\n      errors: _,\n      ...rest\n    } = Array.isArray(result) ? result : result;\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;\n    const dataEnvelope = isBatchingQuery ? {\n      data\n    } : data;\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status\n    };\n  } else {\n    const errorResult = typeof result === `string` ? {\n      error: result\n    } : result;\n    throw new ClientError(\n    // @ts-expect-error TODO\n    {\n      ...errorResult,\n      status: response.status,\n      headers: response.headers\n    }, {\n      query,\n      variables\n    });\n  }\n};\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest = async (...args) => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args;\n  const requestOptions = parseRawRequestExtendedArgs(urlOrOptions, query, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.rawRequest({\n    ...requestOptions\n  });\n};\n// prettier-ignore\n// eslint-disable-next-line\nasync function request(urlOrOptions, document, ...variablesAndRequestHeaders) {\n  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.request({\n    ...requestOptions\n  });\n}\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests = async (...args) => {\n  const params = parseBatchRequestsArgsExtended(args);\n  const client = new GraphQLClient(params.url);\n  return client.batchRequests(params);\n};\nconst parseBatchRequestsArgsExtended = args => {\n  if (args.length === 1) {\n    return args[0];\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined\n    };\n  }\n};\nconst createRequestBody = (query, variables, operationName, jsonSerializer) => {\n  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer;\n  if (!Array.isArray(query)) {\n    return jsonSerializer_.stringify({\n      query,\n      variables,\n      operationName\n    });\n  }\n  if (typeof variables !== `undefined` && !Array.isArray(variables)) {\n    throw new Error(`Cannot create request body with given variable type, array expected`);\n  }\n  // Batch support\n  const payload = query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: currentQuery,\n      variables: variables ? variables[index] : undefined\n    });\n    return acc;\n  }, []);\n  return jsonSerializer_.stringify(payload);\n};\nconst getResult = async (response, jsonSerializer) => {\n  let contentType;\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value;\n    }\n  });\n  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {\n    return jsonSerializer.parse(await response.text());\n  } else {\n    return response.text();\n  }\n};\nconst callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n * ```\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks, ...variables) => {\n  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);\n};\nexport { GraphQLWebSocketClient } from './graphql-ws.js';\nexport { resolveRequestDocument } from './resolveRequestDocument.js';\nexport { batchRequests, ClientError, GraphQLClient, rawRequest, request };\nexport default request;","map":{"version":3,"names":["defaultJsonSerializer","HeadersInstanceToPlainObject","uppercase","parseBatchRequestArgs","parseRawRequestArgs","parseRawRequestExtendedArgs","parseRequestArgs","parseRequestExtendedArgs","resolveRequestDocument","ClientError","crossFetch","CrossFetch","resolveHeaders","headers","oHeaders","Headers","Array","isArray","forEach","name","value","undefined","cleanQuery","str","replace","trim","buildRequestConfig","params","query","params_","search","encodeURIComponent","variables","push","jsonSerializer","stringify","operationName","join","Error","payload","reduce","acc","currentQuery","index","createHttpMethodFetcher","method","url","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","Promise","resolve","urlNew","initNew","GraphQLClient","constructor","requestConfig","rawRequest","args","queryOrOptions","requestHeaders","rawRequestOptions","requestMiddleware","responseMiddleware","signal","makeRequest","callOrIdentity","then","response","catch","error","request","documentOrOptions","variablesAndRequestHeaders","requestOptions","document","data","batchRequests","documentsOrOptions","batchRequestOptions","queries","documents","map","setHeaders","setHeader","key","setEndpoint","fetcher","isBatchingQuery","getResult","successfullyReceivedData","some","Boolean","successfullyPassedErrorPolicy","errors","length","errorPolicy","ok","_","rest","dataEnvelope","status","errorResult","urlOrOptions","client","parseBatchRequestsArgsExtended","jsonSerializer_","contentType","toLowerCase","startsWith","parse","text","gql","chunks","chunk","String","GraphQLWebSocketClient"],"sources":["/Users/felipe-note/dev/tarkov-app/node_modules/graphql-request/src/index.ts"],"sourcesContent":["import { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type {\n  BatchRequestDocument,\n  FetchOptions,\n  GraphQLClientRequestHeaders,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  MaybeLazy,\n  RequestConfig,\n  RequestMiddleware,\n  ResponseMiddleware,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers?: GraphQLClientRequestHeaders): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: RequestInit) => Promise<Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: FetchOptions\n  variables?: V\n  headers?: GraphQLClientRequestHeaders\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<GraphQLClientResponse<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: GraphQLClientRequestHeaders): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>, requestHeaders?: GraphQLClientRequestHeaders): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: GraphQLClientRequestHeaders): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-expect-error todo\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: GraphQLClientRequestHeaders\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: FetchOptions\n  middleware?: RequestMiddleware<V>\n}): Promise<GraphQLClientResponse<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors: _, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: GraphQLClientRequestHeaders): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<GraphQLClientResponse<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: GraphQLClientRequestHeaders]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<GraphQLClientResponse<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<GraphQLClientResponse<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\n// REMARKS: In order to have autocomplete for options work make it the first overload. If not\n// then autocomplete will instead show the various methods for a string, which is not what we want.\n// prettier-ignore\nasync function request<T, V extends Variables = Variables>(options: RequestExtendedOptions<V, T>): Promise<T>\n// prettier-ignore\nasync function request<T, V extends Variables = Variables>(url: string, document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n// prettier-ignore\n// eslint-disable-next-line\nasync function request<T, V extends Variables = Variables>(urlOrOptions: string | RequestExtendedOptions<V, T>, document?: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T> {\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: GraphQLClientRequestHeaders): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: GraphQLClientRequestHeaders]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nconst createRequestBody = (\n  query: string | string[],\n  variables?: Variables | Variables[],\n  operationName?: string,\n  jsonSerializer?: JsonSerializer\n): string => {\n  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer\n  if (!Array.isArray(query)) {\n    return jsonSerializer_.stringify({ query, variables, operationName })\n  }\n\n  if (typeof variables !== `undefined` && !Array.isArray(variables)) {\n    throw new Error(`Cannot create request body with given variable type, array expected`)\n  }\n\n  // Batch support\n  const payload = query.reduce<{ query: string; variables: Variables | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({ query: currentQuery, variables: variables ? variables[index] : undefined })\n      return acc\n    },\n    []\n  )\n\n  return jsonSerializer_.stringify(payload)\n}\n\nconst getResult = async (\n  response: Response,\n  jsonSerializer: JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeLazy<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n * ```\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: unknown[]): string => {\n  return chunks.reduce(\n    (acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\nexport {\n  BatchRequestDocument,\n  batchRequests,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  GraphQLClient,\n  rawRequest,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  request,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestMiddleware,\n  RequestOptions,\n  ResponseMiddleware,\n  Variables,\n}\nexport default request\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}